# Лабораторная работа 1
## Вариант: M2+M4(с некоторым дополнениями :D)

* **Цель:** Написать калькулятор на Python с возможностью введения пользовательских функций и переменных(+операторов)
* **Библиотеки:** *dataclass*, *decimal*, *string*, *sys*, *logging*, *math*
* **Допущения:**
  - Имена функций и переменных не могут содержать в себе операторы и пробелы
  - Символы [] запрещены
  - Унарный '-' заменяется на опреацию -1*
  - Унарный '+' игнорируется
  - Если перед унарной операцией следовала другая операция, выводится предупреждение
  - Если число можно представить в виде целого, оно представляется в виде целого. В противном случае используется число с фиксированной точкой(для более точных вычислений)
  - Операции '//' и  '%' запрещены для вещественных чисел
  - Запрещено перезаписывать разные типы(например, перезаписать функцию f(x) переменной f)
  - В константах(**constants.py**) можно указать максимальное кол-во знаков числа, а также формат экспоненциальной нотации(или оставить None для стандартной записи)
  - Задавать имена после выражения недопустимо
  - Рекурсия недопустима
  - Значения переменных задаются один раз. Например, запись ```let x = 5; let x = x+5; x``` недопустима
  - 0**0 не определен

* **Чему я научился:**
    - Написание простых автотестов с помощью pytest
    - Разделение логики по функциям, классам, модулям
    - Использование стэка

### Алгоритм решения
  1. Пользователь вводит выражение(или q, если хочет завершить работу программы)
  2. Программа проводит базовую валидацию(**validator.PreCompiledValidator**): проверяет сбалансированны ли в выражении скобки, не задает ли пользователь уже занятыми именами(например, переопределение функций и системных имен)
  3. Из выражения вытаскиваются заданные переменные, функции и операции(с их валидацией, **compiler.CompiledExpression**)
  4. Проверяется валидность заданных имен: в них не должны содержатся буквы, пробелы, для функций и переменных запрещено содержание в своих именах операторов(в том числе заданных пользователем)
  5. Все заданные имена попадают в глобальный scope имен(extra.types.Context), в котором содержатся заданные свойства и выражение, тождественное заданному имени
  6. Скомпилированное выражение попадает в токенизатор, который итерируется по выражению работает по следующим правилам:
        - Если это + или -, вводится доп. флаг(по умолчанию True): если след. символ можно представить в виде числа(например, это функция, переменная или просто число), флаг становится False
        - Для текущего символа находятся все имена, которые начинаются с последнего добавленного токена + текущего символа. Если такие имена существуют(+доп флаг), к последнему токену приписывается текущий символ, переход к след символу
        - Если есть имена, начинающиеся с текущего символа(+доп флаг), он добавляется к списку токенов, переход к след символу
        - Если символ - пробел, предыдущий токен пробелом не является, он добавляется к списку токенов
        - Если символ - число(+ '.' и 'е') и предыдущий токен тоже число, символ добавляется к предыдущему токену; если предыдущий токен числом не является, текущий токен добавляется к новому
        - Если предыдущий токен - функция, текущий символ - не '(', поднимается ошибка
        - Если предыдущий токен - функция, текущий символ - '(', к токенам добавляется '[', функция записывается в **стэк функций**, содержащий в себе имя функции, кол-во аргументов, баланс скобок
        - Если текущий символ - скобка она добавляется к токенам
        - Если текущий символ - '(', **стэк функций** не пуст, к балансу скобок добавляется 1
        - Если текущий символ - ')', **стэк функций** не пуст, из баланса скобок вычитается 1. Если баланс скобок стал отрицательным, заменяется добавленную ')' на ']'. Если кол-во аргументов меньше минимального, поднимается ошибка
        - Если текущий символ - ',', добавляем к количеству аргументов последней функции добавляется 1. Если аргументов больше максимального количества, вызывается ошибка
        - Если кол-во токенов не менее 2, проверяется, не попадает ли второй с конца токен в **буфер внешних имен** (см. ниже)
        - Если кол-во токенов не менее 3, 2 с конца токен - пробел, 3 и 1 с конца токены могут быть представлены числами, вызывается ошибка
        - В конце проверяется, не начинается ли список токенов с операций, не попадает ли последний токен в **буфер внешних имен**
  7. Токены преобразуются в RPN алгоритмом шунтирующего двора(с дополнениями :D):
        - Если текущий токен - функция, он добавляется в **стэк функций**
        - Если текущий **стэк функций** не пуст, дальнейшие токены добавляются в аргументы функции(разделяя запятой)
        - Если текущий токен - ']', результат выполнения функции с аргументами ищется в кэше. Если не найдено, добавляется в **буфер внешних имен**, чтобы исключить бесконечную рекурсию, значение тождественного ей выражения вычисляется рекурсивно(аргументы считаются локальными переменными и перезаписывают в новом объектке глобальные). Результат выполнения функции добавляется в токены предыдущего элемента стэка функций, если он есть; иначе - в стэк с числами
        - Если текущий токен - переменная, ее значение ищется к кэше. Если не найдено, значение тождественного ей выражения вычисляется рекурсивно(с шага 2). Имя переменной(если не является локальной) добавляется в **буфер внешних имен**
        - Выполнение пользовательского оператора(вычисление тождественного выражения) тоже выполняется рекурсивно с добавлением в **буфер внешних имен**
        - Все остальные правила совпадают с алгоритмом шунтирующего двора
  8. Результат возвращается и выводится пользователю
  9. Возврат к шагу 1

## Интересные тест-кейсы
 - Скобки сбалансированы по количеству, но введены как )(
 - Функции, операторы, переменные, перезаписывают системные имена и функции по умолчанию(н., ```def max(): return 1; let return = 3; operator 'operator': ...```)
 - Рекурсивно-заданные имена(```def f(x): return f(x); let x = x+5; operator '->': 2, l->r, false;...```)
 - Пустые скобки(не у функции)
 - Пустые скобки(фукнция без аргументов)
 - Аргумент без значения по умолчанию после аргумента со значением по умолчанию

## Инструкция к использованию

### Установить репозиторий
```pip install -e git+https://github.com/stepzak/lab-1#egg=lab1-m2-m4``` \
```cd src/lab1-m2-m4```

### Запустить
```python -m src.main```

### Синтаксис
* В качестве разделителей используется ';'
* Объявление переменной: ```let x = 5; x+5``` - задаст переменой *x* значение *5* и выведет в консоль 10
* Объявление функции: ```def func1(arg1, arg2): return arg1+ arg2; func1(2, 5)``` - задаст функцию func1 с аргументами arg1, arg2, которая возвращает значение, равное arg1+arg2; в выражении вызовет ее с аргументами 2, 5, т.е. выведет 2+5=7
* Значения по умолчанию: ```def ГООЛ(arg1, arg2 = 3): return arg1+arg2; ГООЛ(2)``` - задаст функцию ГООЛ с аргументами arg1, arg2; значение arg2 по умолчанию - 3; вызовет функцию ГООЛ(2) = 2+3=5
* Объявление оператора: ```operator '***': 3, l**r, false; 2***3***2``` - задаст оператор '\***'(должен указываться в одинарных кавычках). После двоеточия указываются свойства: {приоритет}, {выражение}, {правоассоциативность}. В выражении локальные переменные ***l*** и ***r*** - левые и правые операнды соответственно. Если последним аргументом передалось true или 1, оператор будет считаться правоассоциативным(не чувствительно к регистру). Иными словами, заданный оператор - левоассоциативное возведение в степень. Конечный результат выполнения: (2\**3)\**2=8\**2=64
